# 折り紙の折り動作 実装方針（ステップ 3）

## 概要

既に計算された折り線（start, end）に基づいて、折り紙を実際に折る動作を実装する。
既存実装（`src/components/OrigamiPost/logics/`）を参考にしつつ、v2 ではよりシンプルで保守性の高いアーキテクチャを目指す。

## 全体の処理フロー

```
1. 折り線の確定（既存: useDropHandler）
   ↓
2. 板の分割（新規: dividePlane）
   ↓
3. どちらの板を動かすか決定（新規: useFoldingController）
   ↓
4. 回転アニメーション（新規: useFoldAnimation）
   ↓
5. シーンの更新（新規: useSceneManager）
```

## 完成した実装

### ✅ 1. 板の分割ユーティリティ（完成）

**ファイル**: `utils/dividePlane/index.ts`

**目的**: 折り線で折り紙を 2 つの板に分割する（折る側と固定側）

**入力**:

- `plane`: 現在の折り紙の頂点配列 (THREE.Vector3[])
- `foldLineStart`: 折り線の始点（`calculateFoldLineIntersections` で計算済み）
- `foldLineEnd`: 折り線の終点（`calculateFoldLineIntersections` で計算済み）
- `originalPoint`: ドラッグ開始時の点（どちらが折る側かを判定）

**出力**:

```typescript
{
  movingPart: THREE.Vector3[],  // 折る側の頂点配列
  fixedPart: THREE.Vector3[]    // 固定される側の頂点配列
}
```

**実装のポイント**:

1. **頂点の分類**: XY 平面上で外積の Z 成分を使って各頂点が折り線の左側か右側かを判定
2. **交点の追加**: `foldLineStart` と `foldLineEnd` を両方の配列に追加（重複チェック付き）
3. **折る側の判定**: `originalPoint` の位置で自動的に判定

**座標系**: XY 平面（Z=0）を前提とする

**テスト**: ✅ 2 テスト合格（水平分割、対角線分割）

---

## 次に実装するモジュール

### 2. 折り動作の実装（次のステップ）

**実装の方針**:

折り動作の実装は、以下の 2 つのアプローチが考えられます：

#### アプローチ A: アニメーションなしでシンプルに実装（推奨・第一段階）

まずは回転を即座に適用して、折り紙が正しく折れることを確認する。

**処理の流れ**:

1. `dividePlane` で板を分割
2. 分割された頂点を既存の `renderBoard` を参考にメッシュ化
3. 回転行列を使って `movingPart` を 180 度回転
4. シーンに追加して表示

**実装場所**: `useDropHandler` 内で直接実装

```typescript
const handleMouseUp = () => {
  // ... 既存の折り線計算 ...

  // 1. 板を分割
  const divided = dividePlane(
    currentPlane.vertices,
    intersections.start,
    intersections.end,
    originalPoint
  );

  // 2. 回転軸の方向ベクトル
  const axis = new THREE.Vector3()
    .subVectors(intersections.end, intersections.start)
    .normalize();

  // 3. movingPartを180度回転
  const rotatedMovingPart = divided.movingPart.map((vertex) => {
    const v = vertex.clone();
    // 折り線の始点を原点として回転
    v.sub(intersections.start);
    v.applyAxisAngle(axis, Math.PI); // 180度回転
    v.add(intersections.start);
    return v;
  });

  // 4. メッシュを生成してシーンに追加
  renderBoard({ scene, board: divided.fixedPart, color });
  renderBoard({ scene, board: rotatedMovingPart, color });

  // 5. 元の折り紙を非表示
  // ...
};
```

**メリット**:

- シンプルで理解しやすい
- デバッグが容易
- 動作確認が早い

#### アプローチ B: アニメーション付き（第二段階）

アプローチ A が動作確認できたら、アニメーションを追加する。

**実装するフック**: `useFoldAnimation`

```typescript
const useFoldAnimation = ({
  vertices,
  foldLineStart,
  foldLineEnd,
  onUpdate,
}: {
  vertices: THREE.Vector3[];
  foldLineStart: THREE.Vector3;
  foldLineEnd: THREE.Vector3;
  onUpdate: (rotatedVertices: THREE.Vector3[]) => void;
}) => {
  const startAnimation = () => {
    // requestAnimationFrame で徐々に角度を増やす
    // onUpdate で現在の回転状態を通知
  };

  return { startAnimation, isAnimating };
};
```

---

### 3. 実装の統合

既存の `useDropHandler` に折り動作を統合する形で実装します。

**統合先**: `hooks/useDropHandler/index.tsx`

**追加する処理**:

```typescript
const handleMouseUp = () => {
  if (!isDragging || !draggedPointMesh || !originalPoint) return;

  const finalPoint = draggedPointMesh.position.clone();

  // 折り線を計算
  const foldLine = calculateFoldLine(originalPoint, finalPoint);
  if (!foldLine) return;

  const intersections = calculateFoldLineIntersections(
    foldLine.midpoint,
    foldLine.direction,
    size
  );

  // 折り線を可視化
  visualizeFoldLine(scene, intersections.start, intersections.end);

  // --- ここから新規追加 ---

  // 1. 板を分割
  const divided = dividePlane(
    currentPlane.vertices, // 現在の折り紙の頂点
    intersections.start,
    intersections.end,
    originalPoint
  );

  // 2. 回転軸の方向ベクトル
  const axis = new THREE.Vector3()
    .subVectors(intersections.end, intersections.start)
    .normalize();

  // 3. movingPartを180度回転
  const rotatedMovingPart = divided.movingPart.map((vertex) => {
    const v = vertex.clone();
    v.sub(intersections.start);
    v.applyAxisAngle(axis, Math.PI);
    v.add(intersections.start);
    return v;
  });

  // 4. メッシュを生成してシーンに追加
  // （既存のrenderBoard関数を使用）
  renderBoard({ scene, board: divided.fixedPart, color });
  renderBoard({ scene, board: rotatedMovingPart, color });

  // 5. 元の折り紙を非表示
  currentPlane.mesh.visible = false;

  // --- ここまで新規追加 ---

  // ドラッグ状態をリセット
  setIsDragging(false);
  // ...
};
```

**必要な準備**:

1. `currentPlane` の状態を追加（現在の折り紙の頂点とメッシュを保持）
2. `renderBoard` 関数を v2 用に調整（既存のロジックを流用）

---

## 実装の段階的アプローチ

### ✅ フェーズ 1: 板の分割（完了）

**実装済み**:

- ✅ `dividePlane` - 折り線で折り紙を 2 つに分割（テスト 2 件合格）

**学んだこと**:

- 交点計算は `calculateFoldLineIntersections` で完了済み
- `originalPoint` で折る側を自動判定できる
- シンプルな実装が可能

---

### 🔄 フェーズ 2: 折り動作の実装（次のステップ）

**目標**: 分割した板を回転させて折り紙を折る

**実装手順**:

#### ステップ 2-1: アニメーションなしで即座に折る（推奨・第一段階）

1. **`renderBoard` の準備**

   - 既存の `src/components/OrigamiPost/logics/renderBoard.ts` を参考
   - `Point[]` を `THREE.Vector3[]` に対応させる

2. **`useDropHandler` に折り処理を追加**

   ```typescript
   // 1. 板を分割
   const divided = dividePlane(...);

   // 2. 回転軸を計算
   const axis = new THREE.Vector3()
     .subVectors(intersections.end, intersections.start)
     .normalize();

   // 3. movingPartを回転
   const rotatedMovingPart = divided.movingPart.map(vertex => {
     const v = vertex.clone();
     v.sub(intersections.start);
     v.applyAxisAngle(axis, Math.PI); // 180度
     v.add(intersections.start);
     return v;
   });

   // 4. シーンに追加
   renderBoard({ scene, board: divided.fixedPart, color });
   renderBoard({ scene, board: rotatedMovingPart, color });
   ```

3. **動作確認**
   - ドラッグ&ドロップで折り紙が折れることを確認
   - 折り線が正しい位置にあることを確認
   - 表裏の色が正しいことを確認

**期待される結果**:

- ドラッグした方向に折り紙が即座に折れる
- 折り線が可視化される
- 元の折り紙が非表示になる

---

#### ステップ 2-2: アニメーションを追加（第二段階・オプション）

ステップ 2-1 が完了したら、滑らかなアニメーションを追加する。

```typescript
const useFoldAnimation = ({
  vertices,
  foldLineStart,
  foldLineEnd,
  duration = 1000,
}: {
  vertices: THREE.Vector3[];
  foldLineStart: THREE.Vector3;
  foldLineEnd: THREE.Vector3;
  duration?: number;
}) => {
  // requestAnimationFrame で徐々に回転
  // 途中経過を返す
};
```

---

### 📋 フェーズ 3: 複数回折り対応（将来）

1. 折った後の状態を `currentPlane` として保存
2. 再度ドラッグ&ドロップで次の折り線を指定
3. 履歴管理（Undo/Redo）

---

### 📋 フェーズ 4: UI/UX の改善（将来）

1. 折り動作の手動トリガー（ボタン）
2. アニメーション速度の調整
3. 折り角度の選択（90 度 or 180 度）
4. 折り線の表示/非表示切り替え

---

## 既存コードとの主な違い

| 項目           | 既存実装                           | v2 実装                         |
| -------------- | ---------------------------------- | ------------------------------- |
| 座標表現       | `Point = [number, number, number]` | `THREE.Vector3`                 |
| 回転処理       | 即時回転                           | アニメーション付き回転          |
| 板の表現       | `Board = Point[]`                  | `THREE.Group` (Mesh + Material) |
| ジオメトリ生成 | 1 つの関数で全て                   | 分離された複数の関数            |
| 状態管理       | 複雑な Procedure 構造              | シンプルな履歴管理              |

---

## パフォーマンス考慮事項

1. **ジオメトリの使い回し**
   - 折った後のジオメトリを破棄せず、再利用の検討
2. **アニメーションの最適化**
   - `requestAnimationFrame` を使用
   - 不要な再計算を避ける
3. **メモリ管理**
   - 古いメッシュ・ジオメトリの適切な破棄
   ```typescript
   const disposeMesh = (mesh: THREE.Group) => {
     mesh.traverse((child) => {
       if (child instanceof THREE.Mesh) {
         child.geometry.dispose();
         if (Array.isArray(child.material)) {
           child.material.forEach((m) => m.dispose());
         } else {
           child.material.dispose();
         }
       }
     });
   };
   ```

---

## テスト方針

### 単体テスト（Vitest）

**✅ 完了**:

1. ✅ `dividePlane` - 2 テスト（水平分割、対角線分割）

**🔄 今後追加予定**:

- 折り動作のロジックテスト（回転計算など）

### 手動テスト（ブラウザ）

**🔄 次のステップ**:

1. ドラッグ&ドロップで折り線が表示されるか
2. 折り紙が正しく折れるか
3. 表裏の色が正しいか
4. 複数回折れるか

### 統合テスト（Storybook・将来）

1. 折り線表示 → 折り動作の一連の流れ
2. アニメーションの視覚的確認
3. 複数回折る動作

---

## 今後の拡張計画

1. **複数回折り**
   - 折った後の状態を新しい `currentPlane` として保存
   - 再度ドラッグ&ドロップで次の折り線を指定
2. **Undo/Redo**
   - `useSceneManager` の履歴機能を活用
3. **折りパターンの保存**
   - 各折りステップの情報を JSON として保存
   - 既存の `Procedure` 型との互換性を考慮
4. **物理演算**
   - より現実的な折り紙の動き
   - 重力や慣性の考慮

---

## 実装の優先順位

**✅ 完了**:

1. ✅ `dividePlane` - 板の分割（テスト 2 件合格）

**🔄 次に実装すべきもの（MVP）**:

1. 🔄 `renderBoard` の v2 対応（`Point[]` → `THREE.Vector3[]`）
2. 🔄 `useDropHandler` に折り処理を追加（アニメーションなし）
3. 🔄 動作確認（折り紙が正しく折れるか）

**📋 その後の拡張**:

- アニメーション機能（`useFoldAnimation`）
- 複数回折り対応
- 履歴管理（Undo/Redo）
- UI コントロール（ボタン、スライダーなど）

**将来の拡張**:

- 物理演算
- 折りパターンの保存・読み込み
- より高度なアニメーション（イージング、バネなど）
