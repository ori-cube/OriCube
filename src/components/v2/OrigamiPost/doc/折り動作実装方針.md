# 折り紙の折り動作 実装方針（ステップ 3）

## 概要

既に計算された折り線（start, end）に基づいて、折り紙を実際に折る動作を実装する。
既存実装（`src/components/OrigamiPost/logics/`）を参考にしつつ、v2 ではよりシンプルで保守性の高いアーキテクチャを目指す。

## 全体の処理フロー

```
1. 折り線の確定（useDropHandler）
   ↓
2. 板の分割（dividePlane）
   ↓
3. 折る側の自動判定（dividePlaneで実装済み）
   ↓
4. 回転処理（THREE.Vector3.applyAxisAngle）
   ↓
5. メッシュ生成とシーンへの追加（renderBoard）
```

## 完成した実装

### ✅ 1. 板の分割ユーティリティ（完成）

**ファイル**: `utils/dividePlane/index.ts`

**目的**: 折り線で折り紙を 2 つの板に分割する（折る側と固定側）

**入力**:

- `plane`: 現在の折り紙の頂点配列 (THREE.Vector3[])
- `foldLineStart`: 折り線の始点（`calculateFoldLineIntersections` で計算済み）
- `foldLineEnd`: 折り線の終点（`calculateFoldLineIntersections` で計算済み）
- `originalPoint`: ドラッグ開始時の点（どちらが折る側かを判定）

**出力**:

```typescript
{
  movingPart: THREE.Vector3[],  // 折る側の頂点配列
  fixedPart: THREE.Vector3[]    // 固定される側の頂点配列
}
```

**実装のポイント**:

1. **頂点の分類**: XY 平面上で外積の Z 成分を使って各頂点が折り線の左側か右側かを判定
2. **交点の追加**: `foldLineStart` と `foldLineEnd` を両方の配列に追加（重複チェック付き）
3. **折る側の判定**: `originalPoint` の位置で自動的に判定

**座標系**: XY 平面（Z=0）を前提とする

**テスト**: ✅ 2 テスト合格（水平分割、対角線分割）

---

## 次に実装するモジュール

### 2. 折り動作の実装（次のステップ）

**実装の方針**: 回転を即座に適用して、折り紙が正しく折れることを確認する

**処理の流れ**:

1. `dividePlane` で板を分割
2. 分割された頂点を既存の `renderBoard` を参考にメッシュ化
3. 回転行列を使って `movingPart` を 180 度回転
4. シーンに追加して表示

**実装場所**: `useDropHandler` 内で直接実装

```typescript
const handleMouseUp = () => {
  // ... 既存の折り線計算 ...

  // 1. 板を分割
  const divided = dividePlane(
    currentPlane.vertices,
    intersections.start,
    intersections.end,
    originalPoint
  );

  // 2. 回転軸の方向ベクトル
  const axis = new THREE.Vector3()
    .subVectors(intersections.end, intersections.start)
    .normalize();

  // 3. movingPartを180度回転
  const rotatedMovingPart = divided.movingPart.map((vertex) => {
    const v = vertex.clone();
    // 折り線の始点を原点として回転
    v.sub(intersections.start);
    v.applyAxisAngle(axis, Math.PI); // 180度回転
    v.add(intersections.start);
    return v;
  });

  // 4. メッシュを生成してシーンに追加
  renderBoard({ scene, board: divided.fixedPart, color });
  renderBoard({ scene, board: rotatedMovingPart, color });

  // 5. 元の折り紙を非表示
  currentPlane.mesh.visible = false;
};
```

**実装のメリット**:

- シンプルで理解しやすい
- デバッグが容易
- 動作確認が早い
- パフォーマンスが良い（アニメーション処理なし）

---

### 3. 実装の統合

既存の `useDropHandler` に折り動作を統合する形で実装します。

**統合先**: `hooks/useDropHandler/index.tsx`

**追加する処理**:

```typescript
const handleMouseUp = () => {
  if (!isDragging || !draggedPointMesh || !originalPoint) return;

  const finalPoint = draggedPointMesh.position.clone();

  // 折り線を計算
  const foldLine = calculateFoldLine(originalPoint, finalPoint);
  if (!foldLine) return;

  const intersections = calculateFoldLineIntersections(
    foldLine.midpoint,
    foldLine.direction,
    size
  );

  // 折り線を可視化
  visualizeFoldLine(scene, intersections.start, intersections.end);

  // --- ここから新規追加 ---

  // 1. 板を分割
  const divided = dividePlane(
    currentPlane.vertices, // 現在の折り紙の頂点
    intersections.start,
    intersections.end,
    originalPoint
  );

  // 2. 回転軸の方向ベクトル
  const axis = new THREE.Vector3()
    .subVectors(intersections.end, intersections.start)
    .normalize();

  // 3. movingPartを180度回転
  const rotatedMovingPart = divided.movingPart.map((vertex) => {
    const v = vertex.clone();
    v.sub(intersections.start);
    v.applyAxisAngle(axis, Math.PI);
    v.add(intersections.start);
    return v;
  });

  // 4. メッシュを生成してシーンに追加
  // （既存のrenderBoard関数を使用）
  renderBoard({ scene, board: divided.fixedPart, color });
  renderBoard({ scene, board: rotatedMovingPart, color });

  // 5. 元の折り紙を非表示
  currentPlane.mesh.visible = false;

  // --- ここまで新規追加 ---

  // ドラッグ状態をリセット
  setIsDragging(false);
  // ...
};
```

**必要な準備**:

1. `currentPlane` の状態を追加（現在の折り紙の頂点とメッシュを保持）
2. `renderBoard` 関数を v2 用に調整（既存のロジックを流用）

---

## 実装の段階的アプローチ

### ✅ フェーズ 1: 板の分割（完了）

**実装済み**:

- ✅ `dividePlane` - 折り線で折り紙を 2 つに分割（テスト 2 件合格）

**学んだこと**:

- 交点計算は `calculateFoldLineIntersections` で完了済み
- `originalPoint` で折る側を自動判定できる
- シンプルな実装が可能

---

### 🔄 フェーズ 2: 折り動作の実装（次のステップ）

**目標**: 分割した板を回転させて折り紙を折る

**実装手順**:

1. **`renderBoard` の準備**

   - 既存の `src/components/OrigamiPost/logics/renderBoard.ts` を参考
   - `Point[]` を `THREE.Vector3[]` に対応させる

2. **`useDropHandler` に折り処理を追加**

   ```typescript
   // 1. 板を分割
   const divided = dividePlane(
     currentPlane.vertices,
     intersections.start,
     intersections.end,
     originalPoint
   );

   // 2. 回転軸を計算
   const axis = new THREE.Vector3()
     .subVectors(intersections.end, intersections.start)
     .normalize();

   // 3. movingPartを180度回転
   const rotatedMovingPart = divided.movingPart.map((vertex) => {
     const v = vertex.clone();
     v.sub(intersections.start);
     v.applyAxisAngle(axis, Math.PI); // 180度
     v.add(intersections.start);
     return v;
   });

   // 4. シーンに追加
   renderBoard({ scene, board: divided.fixedPart, color });
   renderBoard({ scene, board: rotatedMovingPart, color });

   // 5. 元の折り紙を非表示
   currentPlane.mesh.visible = false;
   ```

3. **動作確認**
   - ドラッグ&ドロップで折り紙が折れることを確認
   - 折り線が正しい位置にあることを確認
   - 表裏の色が正しいことを確認

**期待される結果**:

- ドラッグした方向に折り紙が即座に折れる
- 折り線が可視化される
- 元の折り紙が非表示になる

---

### 📋 フェーズ 3: 複数回折り対応（将来）

1. 折った後の状態を `currentPlane` として保存
2. 再度ドラッグ&ドロップで次の折り線を指定
3. 履歴管理（Undo/Redo）

---

### 📋 フェーズ 4: UI/UX の改善（将来）

1. 折り動作の手動トリガー（ボタン）
2. 折り角度の選択（90 度 or 180 度）
3. 折り線の表示/非表示切り替え
4. 色の変更機能

---

## 既存コードとの主な違い

| 項目           | 既存実装                           | v2 実装                         |
| -------------- | ---------------------------------- | ------------------------------- |
| 座標表現       | `Point = [number, number, number]` | `THREE.Vector3`                 |
| 回転処理       | 即時回転                           | アニメーション付き回転          |
| 板の表現       | `Board = Point[]`                  | `THREE.Group` (Mesh + Material) |
| ジオメトリ生成 | 1 つの関数で全て                   | 分離された複数の関数            |
| 状態管理       | 複雑な Procedure 構造              | シンプルな履歴管理              |

---

## パフォーマンス考慮事項

1. **ジオメトリの使い回し**
   - 折った後のジオメトリを破棄せず、再利用の検討
2. **メモリ管理**

   - 古いメッシュ・ジオメトリの適切な破棄

   ```typescript
   const disposeMesh = (mesh: THREE.Group) => {
     mesh.traverse((child) => {
       if (child instanceof THREE.Mesh) {
         child.geometry.dispose();
         if (Array.isArray(child.material)) {
           child.material.forEach((m) => m.dispose());
         } else {
           child.material.dispose();
         }
       }
     });
   };
   ```

3. **不要な再計算を避ける**
   - 回転軸は一度計算したら再利用
   - 頂点のクローンは最小限に

---

## テスト方針

### 単体テスト（Vitest）

**✅ 完了**:

1. ✅ `dividePlane` - 2 テスト（水平分割、対角線分割）

**🔄 今後追加予定**:

- 折り動作のロジックテスト（回転計算など）

### 手動テスト（ブラウザ）

**🔄 次のステップ**:

1. ドラッグ&ドロップで折り線が表示されるか
2. 折り紙が正しく折れるか
3. 表裏の色が正しいか
4. 回転軸が正確か（折り線に沿って折れるか）
5. 複数回折れるか（将来）

### 統合テスト（Storybook・将来）

1. 折り線表示 → 折り動作の一連の流れ
2. 複数回折る動作
3. エッジケース（頂点を通る折り線など）

---

## 今後の拡張計画

1. **複数回折り**
   - 折った後の状態を新しい `currentPlane` として保存
   - 再度ドラッグ&ドロップで次の折り線を指定
2. **Undo/Redo**
   - `useSceneManager` の履歴機能を活用
3. **折りパターンの保存**
   - 各折りステップの情報を JSON として保存
   - 既存の `Procedure` 型との互換性を考慮
4. **物理演算**
   - より現実的な折り紙の動き
   - 重力や慣性の考慮

---

## 実装の優先順位

**✅ 完了**:

1. ✅ `dividePlane` - 板の分割（テスト 2 件合格）

**🔄 次に実装すべきもの（MVP）**:

1. 🔄 `renderBoard` の v2 対応（`Point[]` → `THREE.Vector3[]`）
2. 🔄 `useDropHandler` に折り処理を追加
   - 板の分割
   - 回転計算
   - メッシュ生成とシーン追加
3. 🔄 動作確認（折り紙が正しく折れるか）

**📋 その後の拡張**:

- 複数回折り対応
- 履歴管理（Undo/Redo）
- UI コントロール（ボタン、色変更など）

**将来の拡張**:

- 物理演算
- 折りパターンの保存・読み込み
- スムーズなアニメーション（必要に応じて）
